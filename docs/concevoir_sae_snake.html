<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAE Arkanoid/Snake - Concevoir | Portfolio GEII</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding-top: 80px;
            line-height: 1.6;
        }

        /* ===== NAVIGATION ===== */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.95), rgba(44, 83, 100, 0.95));
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(0, 191, 255, 0.5);
            box-shadow: 0 4px 20px rgba(0, 191, 255, 0.3);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
        }

        .nav-logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #00bfff;
            text-shadow: 0 0 20px rgba(0, 191, 255, 0.8);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
        }

        .nav-logo::before {
            content: '‚ö°';
            font-size: 1.8rem;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .nav-menu {
            display: flex;
            list-style: none;
            gap: 0.5rem;
        }

        .nav-menu > li > a {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.7rem 1.2rem;
            color: rgba(0, 191, 255, 0.9);
            text-decoration: none;
            border-radius: 8px;
            background: rgba(0, 191, 255, 0.05);
            border: 1px solid rgba(0, 191, 255, 0.2);
            transition: all 0.3s ease;
        }

        .nav-menu > li > a.active {
            background: rgba(0, 191, 255, 0.15);
            color: #00ffff;
        }

        .hamburger {
            display: none;
            flex-direction: column;
            gap: 5px;
            cursor: pointer;
        }

        .hamburger span {
            width: 25px;
            height: 3px;
            background: #00bfff;
            border-radius: 3px;
        }

        /* ===== CONTAINER ===== */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        /* ===== TITLES ===== */
        h1 {
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            font-size: 2.5rem;
            text-align: center;
            border-bottom: 4px solid #00bfff;
            padding-bottom: 15px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            animation: fadeInDown 0.8s ease-out;
        }

        h2 {
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            font-size: 2rem;
            margin-top: 50px;
            margin-bottom: 25px;
            padding-left: 15px;
            border-left: 5px solid #00bfff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        }

        h3 {
            color: #00bfff;
            font-size: 1.5rem;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(0, 191, 255, 0.4);
        }

        h4 {
            color: #00bfff;
            font-size: 1.2rem;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        /* ===== IMAGES ===== */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            border: 2px solid rgba(0, 191, 255, 0.4);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5), 0 0 15px rgba(0, 191, 255, 0.3);
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
        }

        img:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6), 0 0 25px rgba(0, 255, 255, 0.5);
        }

        /* ===== TABLES ===== */
        table {
            width: 100%;
            background: rgba(15, 32, 39, 0.8);
            border: 2px solid rgba(0, 191, 255, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            border-collapse: collapse;
            overflow: hidden;
        }

        thead {
            background: linear-gradient(135deg, #0f2027, #2c5364);
        }

        th {
            color: #00ffff;
            font-weight: bold;
            padding: 12px;
            text-align: left;
        }

        td {
            color: #e0e0e0;
            padding: 12px;
            border-bottom: 1px solid rgba(0, 191, 255, 0.2);
        }

        tr:hover {
            background: rgba(0, 191, 255, 0.1);
        }

        /* ===== CONTENT BOX ===== */
        .content-box {
            background: rgba(0, 191, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #00bfff;
            box-shadow: 0 3px 15px rgba(0, 191, 255, 0.2);
        }

        /* ===== BLOCKQUOTE ===== */
        blockquote {
            background: rgba(0, 191, 255, 0.1);
            border-left: 4px solid #00ffff;
            padding: 15px 20px;
            margin: 20px 0;
            font-style: italic;
            color: #00ffff;
        }

        /* ===== CODE ===== */
        pre {
            background: #0f2027;
            border: 1px solid rgba(0, 191, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
        }

        code {
            color: #00bfff;
            font-family: 'Courier New', monospace;
        }

        /* ===== VIDEO EMBED ===== */
        .video-container {
            text-align: center;
            margin: 30px 0;
        }

        .video-container a {
            display: inline-block;
            position: relative;
        }

        .video-container img {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .video-container a:hover img {
            transform: scale(1.05);
            box-shadow: 0 10px 40px rgba(0, 191, 255, 0.6);
        }

        /* ===== HR ===== */
        hr {
            border: none;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00bfff, transparent);
            margin: 40px 0;
        }

        /* ===== ANIMATIONS ===== */
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 1024px) {
            .hamburger {
                display: flex;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>

    <!-- ===== NAVIGATION ===== -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">Portfolio GEII</a>
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html">üè† Accueil</a></li>
                <li><a href="referenciel.html">üìä R√©f√©rentiel</a></li>
                <li><a href="#" class="active">üìö Projets</a></li>
                <li><a href="#">üíº Exp√©rience</a></li>
                <li><a href="contact.html">üìû Contact</a></li>
            </ul>
        </div>
    </nav>

    <!-- ===== CONTAINER ===== -->
    <div class="container">
        
        <h1>üéÆ Portfolio SAE Arkanoid ‚Äì BUT GEII 1√®re Ann√©e</h1>

        <h2>üîπ Comp√©tence : Concevoir</h2>

        <h3>üî∏ Contexte</h3>
        <p>Initialement, notre projet consistait √† r√©aliser une borne d'arcade miniature, mais apr√®s analyse des contraintes (transport, esth√©tique et complexit√©), nous avons pivot√© vers une console portable inspir√©e de la Game Boy.</p>

        <h3>üî∏ Activit√©s r√©alis√©es</h3>

        <h4>üìã Cahier des charges et planification</h4>
        <div class="content-box">
            <ul>
                <li>Analyse des besoins r√©els et adaptation du projet : abandon de la borne d'arcade pour une console portable.</li>
                <li>R√©daction d'un cahier des charges incluant les composants (PIC16F18877, √©cran TFT), contraintes techniques (taille, budget) et moyens disponibles √† l'IUT.</li>
                <li>Utilisation d'un <strong>diagramme de Gantt</strong> pour organiser les t√¢ches et planifier le projet.</li>
            </ul>
        </div>

        <img src="images/Sae snake/diagrame_de_gant.jpg" alt="Diagramme de Gantt">

        <div class="content-box">
            <p><strong>Apprentissage critique :</strong></p>
            <ul>
                <li>Adapter un projet aux contraintes techniques et mat√©rielles.</li>
                <li>Ma√Ætriser la gestion de projet pour assurer le respect des d√©lais.</li>
            </ul>
            <p><strong>Lien avec les mati√®res :</strong></p>
            <ul>
                <li><strong>Communication & PPP</strong> : pr√©sentation et argumentation des choix lors des r√©unions de suivi.</li>
                <li><strong>Automatisme & Informatique industrielle</strong> : structuration des t√¢ches et formalisation du cahier des charges.</li>
            </ul>
        </div>

        <hr>

        <h4>üîß Conception m√©canique (SolidWorks)</h4>
        <div class="content-box">
            <ul>
                <li>Conception 3D du bo√Ætier √† partir de croquis papier et de mesures pr√©cises (pied √† coulisse, datasheet).</li>
                <li>R√©ajustement des dimensions pour int√©grer le PCB prototype.</li>
                <li>Cr√©ation d'un syst√®me de fermeture viss√© inspir√© des calculatrices (impression 3D plus simple √† r√©aliser).</li>
            </ul>
        </div>

        <p><strong>PCB prototype utilis√© :</strong></p>
        <img src="images/Sae snake/PCB_joystique.png" alt="PCB joystick">

        <h3>üì∏ Repr√©sentations du Projet SAE Snake</h3>
        <table>
            <thead>
                <tr>
                    <th>üîç Vue technique</th>
                    <th>üìê Cotation CAO</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><img src="images/Sae snake/Image du croquis.PNG" alt="Croquis"></td>
                    <td><img src="images/Sae snake/cotation_pcb_solidworks.png" alt="Cotation"></td>
                </tr>
            </tbody>
        </table>

        <blockquote>
            üìù √Ä gauche : le <strong>croquis fonctionnel initial</strong> du projet SAE Arcanoid, illustrant les composants cl√©s et leurs connexions logiques.<br>
            üß∞ √Ä droite : la <strong>mod√©lisation d√©taill√©e sous SolidWorks</strong> avec les <strong>cotes pr√©cises du PCB</strong>, utilis√©e pour la fabrication.
        </blockquote>

        <h3>üéØ Bo√Ætier final du projet SAE Snake</h3>
        <table>
            <thead>
                <tr>
                    <th>üî≤ Vue avant</th>
                    <th>üîÑ Vue arri√®re</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><img src="images/Sae snake/boitier_final.png" alt="Bo√Ætier avant"></td>
                    <td><img src="images/Sae snake/arriere_boitier.png" alt="Bo√Ætier arri√®re"></td>
                </tr>
            </tbody>
        </table>

        <p><strong>Petite vid√©o illustrative :</strong></p>
        <div class="video-container">
            <a href="https://youtu.be/8NDEZ3Jczmg" target="_blank">
                <img src="https://img.youtube.com/vi/8NDEZ3Jczmg/hqdefault.jpg" alt="Test du moteur">
            </a>
        </div>

        <blockquote>
            üõ†Ô∏è Le bo√Ætier a √©t√© con√ßu pour <strong>prot√©ger l'√©lectronique</strong> tout en assurant l'acc√®s aux connecteurs.<br>
            üîå <strong>Vue avant</strong> : interfaces utilisateurs et connecteurs accessibles.<br>
            üîß <strong>Vue arri√®re</strong> : acc√®s aux bornes d'alimentation et √©ventuelles a√©rations.
        </blockquote>

        <div class="content-box">
            <p><strong>Apprentissage critique :</strong></p>
            <ul>
                <li>Adapter la conception au fur et √† mesure des tests et impressions.</li>
                <li>Utiliser les it√©rations d'impression 3D pour corriger les d√©fauts.</li>
            </ul>
            <p><strong>Lien avec les mati√®res :</strong></p>
            <ul>
                <li><strong>√âlectronique & Syst√®mes embarqu√©s</strong> : int√©gration m√©canique du PCB.</li>
                <li><strong>Math√©matiques & Physique appliqu√©e</strong> : calculs de dimensions, utilisation du pied √† coulisse.</li>
            </ul>
        </div>

        <hr>

        <h3>üñ®Ô∏è Utilisation de SuperSlicer pour l'impression 3D du bo√Ætier</h3>
        <p>Afin de fabriquer notre bo√Ætier con√ßu sur SolidWorks, j'ai utilis√© <strong>SuperSlicer</strong>, un logiciel de <strong>tranchage 3D</strong> (slicer) qui permet de convertir un mod√®le 3D en <strong>G-code</strong> lisible par l'imprimante 3D.</p>

        <h4>üìù √âtapes r√©alis√©es :</h4>
        <div class="content-box">
            <ul>
                <li>üîç <strong>Chargement du fichier STL</strong> du bo√Ætier (issu de SolidWorks) dans SuperSlicer.</li>
                <li>üîß <strong>Param√©trage des r√©glages d'impression</strong> : hauteur de couche, remplissage, temp√©rature de buse et plateau.</li>
                <li>üìè <strong>Ajustement des supports</strong> et de la premi√®re couche pour assurer une bonne adh√©rence.</li>
                <li>üìÑ <strong>G√©n√©ration du fichier G-code</strong> pr√™t √† √™tre transf√©r√© sur l'imprimante 3D.</li>
                <li>‚úÖ <strong>Test d'impression</strong> et v√©rification des dimensions r√©elles apr√®s fabrication.</li>
            </ul>
        </div>

        <h4>üì∏ Illustration</h4>
        <table>
            <thead>
                <tr>
                    <th>Avant du bo√Ætier</th>
                    <th>Arri√®re du bo√Ætier (PCB)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><img src="images/Sae snake/Imprimer vue de face.jpg" alt="Avant impression"></td>
                    <td><img src="images/Sae snake/arriere_imprimer.jpg" alt="Arri√®re impression"></td>
                </tr>
            </tbody>
        </table>

        <h4>üéì Liens p√©dagogiques</h4>

        <h5>Apprentissage critique</h5>
        <div class="content-box">
            <ul>
                <li>Comprendre le lien entre <strong>mod√©lisation CAO</strong> et <strong>fabrication r√©elle</strong>.</li>
                <li>Apprendre √† r√©gler les param√®tres d'un slicer pour garantir une impression <strong>fiable et pr√©cise</strong>.</li>
                <li>Savoir <strong>corriger les erreurs d'adh√©rence ou de surchauffe</strong> en modifiant le G-code ou les param√®tres.</li>
            </ul>
        </div>

        <h5>Lien avec les comp√©tences GEII</h5>
        <table>
            <thead>
                <tr>
                    <th>Comp√©tence GEII</th>
                    <th>D√©tail</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>C1 ‚Äì Concevoir</strong></td>
                    <td>Transformer une mod√©lisation 3D en objet physique via impression 3D</td>
                </tr>
                <tr>
                    <td><strong>C4 ‚Äì Mettre en ≈ìuvre</strong></td>
                    <td>Configurer une machine √† commande num√©rique (ici l'imprimante) pour produire une pi√®ce</td>
                </tr>
            </tbody>
        </table>

        <h5>üìö Lien avec les mati√®res</h5>
        <div class="content-box">
            <ul>
                <li><strong>Conception assist√©e par ordinateur (CAO)</strong> : lien direct avec le logiciel SolidWorks utilis√©.</li>
                <li><strong>Fabrication num√©rique</strong> : param√©trage, test et validation de l'impression 3D.</li>
                <li><strong>Projet SAE (Snake ou autres)</strong> : int√©gration compl√®te du bo√Ætier dans la solution mat√©rielle du projet.</li>
            </ul>
        </div>

        <blockquote>
            üìå <em>Gr√¢ce √† cette √©tape, j'ai compris que concevoir un bo√Ætier fonctionnel ne se limite pas √† la mod√©lisation : il faut aussi anticiper les contraintes d'impression comme la dilatation, les jeux m√©caniques et la stabilit√© du mod√®le pendant l'impression.</em>
        </blockquote>

        <hr>

        <h4>‚ö° Conception √©lectronique (KiCad)</h4>
        <div class="content-box">
            <ul>
                <li>R√©alisation du sch√©ma √©lectrique complet de la carte son.</li>
                <li>Cr√©ation des fichiers Gerber et validation aupr√®s du constructeur.</li>
                <li>R√©solution d'erreurs de routage (erreurs de fils, probl√®mes de per√ßage).</li>
            </ul>
        </div>

        <h3>üìê Sch√©mas KiCad ‚Äì Conception et Contr√¥le</h3>
        <table>
            <thead>
                <tr>
                    <th>üß† Sch√©ma de carte son (Projet)</th>
                    <th>üìÑ Sch√©ma re√ßu au contr√¥le de SAE</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><img src="images/Sae snake/kikade_carte_son.png" alt="KiCad carte son"></td>
                    <td><img src="images/Sae snake/Realisationd'une autre carte son.png" alt="Contr√¥le SAE"></td>
                </tr>
            </tbody>
        </table>

        <blockquote>
            üéì Ce tableau compare :<br>
            - √Ä gauche : le <strong>sch√©ma √©lectrique que j'ai con√ßu moi-m√™me</strong> sous KiCad, pour la r√©alisation de la carte son du projet SAE Snake.<br>
            - √Ä droite : le <strong>sch√©ma donn√© lors de mon contr√¥le de SAE</strong>, que j'ai d√ª analyser et corriger en temps limit√©.<br><br>
            üîç Cet exercice m'a permis de valider ma capacit√© √† :<br>
            - Lire un sch√©ma √©lectronique inconnu rapidement<br>
            - Rep√©rer les incoh√©rences de routage<br>
            - Appliquer la m√™me rigueur que dans mon projet personnel
        </blockquote>

        <p><strong>Routage de la carte son :</strong></p>
        <img src="images/Sae snake/image.png" alt="Routage">

        <p><strong>Cr√©ation de fichier gerber avec les fichiers per√ßage...</strong></p>
        <img src="images/Sae snake/Capture d'√©cran 2025-06-07 140221.png" alt="Fichier Gerber">
        <img src="images/Sae snake/Capture d'√©cran 2025-06-07 140238.png" alt="Tracer Gerber">

        <p><strong>Simulation chez le constructeur :</strong></p>
        <img src="images/Sae snake/Simulation_constructeur.png" alt="Simulation constructeur">

        <div class="content-box">
            <p><strong>Apprentissage critique :</strong></p>
            <ul>
                <li>Comprendre la cha√Æne de conception et de validation d'un PCB.</li>
                <li>Apprendre √† g√©rer les erreurs et les contraintes du fabricant.</li>
            </ul>
            <p><strong>Lien avec les mati√®res :</strong></p>
            <ul>
                <li><strong>√âlectronique & Syst√®mes embarqu√©s</strong> : sch√©ma √©lectrique, routage, validation des fichiers Gerber.</li>
                <li><strong>Automatisme & Informatique industrielle</strong> : interactions entre le PCB et le microcontr√¥leur.</li>
            </ul>
        </div>

        <hr>

        <h3>üî® Brasure des composants et r√©alisation d'une liste</h3>
        <table>
            <thead>
                <tr>
                    <th>Composant</th>
                    <th>R√©f√©rence</th>
                    <th>Quantit√©</th>
                    <th>Fonction</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Amplificateur</td>
                    <td>LM386N</td>
                    <td>1</td>
                    <td>Amplification audio</td>
                </tr>
                <tr>
                    <td>Potentiom√®tre</td>
                    <td>10kŒ© lin√©aire</td>
                    <td>1</td>
                    <td>Contr√¥le volume</td>
                </tr>
                <tr>
                    <td>Condensateur</td>
                    <td>10¬µF √©lectrolytique</td>
                    <td>2</td>
                    <td>D√©couplage alimentation</td>
                </tr>
                <tr>
                    <td>Condensateur</td>
                    <td>100nF c√©ramique</td>
                    <td>1</td>
                    <td>Filtrage HF</td>
                </tr>
                <tr>
                    <td>Condensateur</td>
                    <td>47nF c√©ramique</td>
                    <td>1</td>
                    <td>Couplage entr√©e</td>
                </tr>
                <tr>
                    <td>Condensateur</td>
                    <td>220¬µF √©lectrolytique</td>
                    <td>1</td>
                    <td>Filtrage sortie</td>
                </tr>
                <tr>
                    <td>R√©sistance</td>
                    <td>10Œ© 1/4W</td>
                    <td>1</td>
                    <td>Protection sortie</td>
                </tr>
                <tr>
                    <td>R√©sistance</td>
                    <td>0Œ© (strap)</td>
                    <td>1</td>
                    <td>Liaison directe</td>
                </tr>
                <tr>
                    <td>Interrupteur</td>
                    <td>ON/OFF</td>
                    <td>1</td>
                    <td>Mise sous tension</td>
                </tr>
                <tr>
                    <td>Connecteurs</td>
                    <td>2.54mm</td>
                    <td>4</td>
                    <td>Liaisons PCB</td>
                </tr>
            </tbody>
        </table>

        <p>Une fois qu'on a dress√© une liste des composants, on est parti braser la carte son sur un poste de soudage :</p>
        <p>On a pu souder les diff√©rents composants :</p>

        <img src="images/Sae snake/PCB_carte_son.png" alt="PCB carte son">

        <div class="content-box">
            <p><strong>Apprentissage critique :</strong> On a appris √† bien braser et d√©tecter les √©ventuelles pannes.</p>
            <p><strong>Comp√©tence & Lien avec la mati√®re :</strong> ELEN</p>
        </div>

        <hr>

        <h2>üîå R√©alisation du c√¢blage global et configuration du microcontr√¥leur</h2>
        <p>Dans le cadre du projet SAE Snake, j'ai r√©alis√© l'<strong>int√©gration mat√©rielle</strong> compl√®te entre les diff√©rents composants : √©cran LCD, carte son, PCB joystick, et carte principale. Cette √©tape repose sur la <strong>configuration du microcontr√¥leur</strong> via <strong>MCC (MPLAB Code Configurator)</strong> ainsi que sur l'interpr√©tation de <strong>datasheets techniques</strong> pour le c√¢blage.</p>

        <h3>üìå Configuration des entr√©es/sorties (MCC)</h3>
        <p>J'ai commenc√© par configurer l'ensemble des <strong>broches d'E/S</strong> (entr√©es/sorties) de mon microcontr√¥leur pour chaque composant connect√© :</p>

        <table>
            <thead>
                <tr>
                    <th>MCC ‚Äì Affectation des broches</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><img src="images/Sae snake/pINmodule1.png" alt="Pin module 1"></td>
                </tr>
                <tr>
                    <td><img src="images/Sae snake/Pinmodule2suit.png" alt="Pin module 2"></td>
                </tr>
            </tbody>
        </table>

        <blockquote>
            üìå Gr√¢ce √† ce pin module, j'ai d√©fini les broches √† utiliser pour :<br>
            - l'√©cran LCD (SPI/I2C),<br>
            - le PCB de prototypage (GPIO, alimentation),<br>
            - la carte son (sortie audio),<br>
            - les joysticks et boutons (entr√©es num√©riques).
        </blockquote>

        <h3>üìö C√¢blage bas√© sur les documentations techniques</h3>
        <p>Pour garantir un c√¢blage correct, j'ai utilis√© les <strong>datasheets</strong> et sch√©mas de r√©f√©rence des composants :</p>

        <h3>üîß Sch√©mas de c√¢blage des composants</h3>
        <table>
            <thead>
                <tr>
                    <th>üéÆ Joystick Shield ‚Äì PCB</th>
                    <th>üñ•Ô∏è √âcran LCD ‚Äì I2C</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><img src="images/Sae snake/Capture d'√©cran 2025-04-24 130112.png" alt="Sch√©ma joystick"></td>
                    <td><img src="images/Sae snake/Ecran_Cablage.jpg" alt="Sch√©ma √©cran"></td>
                </tr>
            </tbody>
        </table>

        <blockquote>
            üîß Ces sch√©mas m'ont permis de :<br>
            - Identifier les <strong>broches de connexion</strong> pour chaque composant.<br>
            - Comprendre les <strong>protocoles utilis√©s</strong> (I2C, entr√©es num√©riques).<br>
            - R√©aliser un <strong>c√¢blage fonctionnel et fiable</strong> dans le respect des tensions et niveaux logiques.
        </blockquote>

        <h3>üéì Liens p√©dagogiques</h3>
        <table>
            <thead>
                <tr>
                    <th>√âl√©ment travaill√©</th>
                    <th>D√©tail</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Comp√©tence vis√©e</strong></td>
                    <td>C1 ‚Äì Concevoir une solution technique (mat√©rielle ou logicielle)</td>
                </tr>
                <tr>
                    <td><strong>Mati√®re associ√©e</strong></td>
                    <td>Informatique embarqu√©e / TP microcontr√¥leur</td>
                </tr>
                <tr>
                    <td><strong>Apprentissage critique</strong></td>
                    <td><strong>C1a : Produire une analyse fonctionnelle d'un syst√®me</strong></td>
                </tr>
                <tr>
                    <td><strong>Justification</strong></td>
                    <td>J'ai √©t√© capable de d√©terminer les fonctions d'entr√©es/sorties, les types de signaux, et les connexions entre composants selon les sp√©cifications mat√©rielles.</td>
                </tr>
                <tr>
                    <td><strong>SAE associ√©e</strong></td>
                    <td>SAE Snake / Carte embarqu√©e connect√©e</td>
                </tr>
            </tbody>
        </table>

        <blockquote>
            üéì <em>Cette phase de conception m'a permis d'apprendre √† lire un sch√©ma technique, configurer un microcontr√¥leur de fa√ßon autonome et concevoir un c√¢blage structur√© pour un syst√®me √©lectronique embarqu√©.</em>
        </blockquote>

        <hr>

        <h2>üîã Choix des composants et gestion √©nerg√©tique</h2>
        <p>Dans cette phase, il a √©t√© essentiel de <strong>s√©lectionner des composants</strong> compatibles entre eux et optimis√©s pour une <strong>consommation √©nerg√©tique ma√Ætris√©e</strong>, en vue d'une alimentation sur batterie rechargeable. Cette d√©marche a impliqu√© une r√©flexion autour des crit√®res suivants :</p>

        <div class="content-box">
            <ul>
                <li>Compatibilit√© en tension (5V ou 3.3V)</li>
                <li>Consommation √©nerg√©tique des composants</li>
                <li>Disponibilit√© des modules</li>
                <li>Facilit√© d'int√©gration dans le syst√®me</li>
                <li>Taille physique des modules</li>
            </ul>
        </div>

        <h4>üìä Tableau estimatif de la consommation par composant :</h4>
        <table>
            <thead>
                <tr>
                    <th>Composant</th>
                    <th>Tension (V)</th>
                    <th>Consommation (mA)</th>
                    <th>Puissance (W)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Microcontr√¥leur PIC16F18877</td>
                    <td>5V</td>
                    <td>40</td>
                    <td>0.20</td>
                </tr>
                <tr>
                    <td>√âcran TFT 2.8" SPI</td>
                    <td>5V</td>
                    <td>60</td>
                    <td>0.30</td>
                </tr>
                <tr>
                    <td>Boutons poussoir (x4)</td>
                    <td>5V</td>
                    <td>10</td>
                    <td>0.05</td>
                </tr>
                <tr>
                    <td>Joystick 4 directions</td>
                    <td>5V</td>
                    <td>20</td>
                    <td>0.10</td>
                </tr>
                <tr>
                    <td>PCB Joystick Shield v1.a</td>
                    <td>5V</td>
                    <td>15</td>
                    <td>0.075</td>
                </tr>
                <tr>
                    <td>Module TP4056 (veille)</td>
                    <td>3.7V</td>
                    <td>10</td>
                    <td>0.037</td>
                </tr>
                <tr>
                    <td>Carte son (AOP LM386)</td>
                    <td>5V</td>
                    <td>25</td>
                    <td>0.125</td>
                </tr>
                <tr>
                    <td><strong>Total estim√©</strong></td>
                    <td>-</td>
                    <td><strong>180 mA</strong></td>
                    <td><strong>‚âà 0.9 W</strong></td>
                </tr>
            </tbody>
        </table>

        <h3>üîå Choix du module de charge et de la batterie</h3>
        <p>Sur la base du tableau pr√©c√©dent, une consommation moyenne de <strong>180 mA</strong> pour le syst√®me complet a √©t√© estim√©e.</p>

        <h4>Choix du module de charge : <strong>TP4056</strong></h4>
        <div class="content-box">
            <ul>
                <li>Module compact, sp√©cialis√© dans la <strong>recharge des batteries Li-ion 3.7V</strong>.</li>
                <li>Int√®gre la <strong>protection contre les surtensions</strong>, surintensit√©s et court-circuits.</li>
                <li>Prend en charge un courant de charge jusqu'√† <strong>1A</strong>, suffisant pour notre batterie et usage.</li>
            </ul>
        </div>

        <img src="images/Sae snake/Module de charge.png" alt="Module de charge">

        <h4>Choix de la batterie : <strong>Batterie Li-ion 3.7V 1000 mAh</strong></h4>
        <div class="content-box">
            <ul>
                <li>R√©cup√©r√©e d'une manette PS4 HS (√©conomie circulaire)</li>
                <li>Donne une autonomie th√©orique ‚âà <strong>5h</strong> (1000 mAh / 180 mA)</li>
                <li>Forme compacte, facile √† int√©grer dans le bo√Ætier</li>
            </ul>
        </div>

        <img src="images/Sae snake/Batteire.png" alt="Batterie">

        <h3>üìö Apprentissage critique :</h3>
        <div class="content-box">
            <ul>
                <li>Savoir <strong>estimer les besoins √©nerg√©tiques</strong> d'un syst√®me embarqu√©.</li>
                <li>Savoir <strong>dimensionner une source d'√©nergie</strong> (batterie + module de charge) selon la <strong>consommation r√©elle</strong>.</li>
                <li>Comprendre <strong>l'√©quilibre entre puissance, encombrement et autonomie</strong>.</li>
                <li>Ma√Ætriser la <strong>conception √©lectronique sous contraintes physiques et √©nerg√©tiques</strong>.</li>
                <li>R√©utiliser un composant (batterie PS4) de mani√®re responsable, en lien avec une <strong>d√©marche √©coresponsable</strong>.</li>
            </ul>
        </div>

        <h3>üìñ Lien avec les mati√®res :</h3>
        <table>
            <thead>
                <tr>
                    <th>Mati√®re</th>
                    <th>Liens concrets dans le projet</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>√âlectronique & Syst√®mes embarqu√©s</strong></td>
                    <td>√âtude du sch√©ma √©lectrique, calcul de consommation, int√©gration du TP4056, conception du circuit de charge</td>
                </tr>
                <tr>
                    <td><strong>Automatisme & Informatique industrielle</strong></td>
                    <td>Interaction entre l'alimentation, le microcontr√¥leur et les entr√©es/sorties du syst√®me</td>
                </tr>
                <tr>
                    <td><strong>Physique appliqu√©e</strong></td>
                    <td>Calcul de puissance, estimation d'autonomie, rendement de charge, gestion thermique</td>
                </tr>
                <tr>
                    <td><strong>Gestion de projet / D√©veloppement durable</strong></td>
                    <td>R√©utilisation de composants, r√©flexion sur la durabilit√© du syst√®me</td>
                </tr>
            </tbody>
        </table>

        <h3>üîß Conception du module de charge sous KiCad</h3>
        <p>Pour valider la solution, le module de charge a √©t√© int√©gr√© dans le sch√©ma global sous <strong>KiCad</strong>. Cela a n√©cessit√© :</p>

        <div class="content-box">
            <ul>
                <li>La cr√©ation du <strong>sch√©ma √©lectrique</strong></li>
                <li>Le <strong>routage manuel</strong> du PCB</li>
                <li>La <strong>g√©n√©ration des fichiers Gerber</strong> pour fabrication</li>
            </ul>
        </div>

        <p><strong>Sch√©ma √©lectrique :</strong></p>
        <img src="images/Sae snake/shcema modulede charge.jpg" alt="Sch√©ma module de charge">

        <hr>

        <h2>üíª Programmation du jeu Arkanoid ‚Äì SAE Snake</h2>

        <div class="content-box">
            <p><strong>Comp√©tence :</strong> C1 ‚Äì Concevoir une solution mat√©rielle ou logicielle</p>
            <p><strong>Mati√®res associ√©es :</strong> Informatique embarqu√©e, Automatisme & Interfaces utilisateur</p>
            <p><strong>Apprentissage critique :</strong> Transformer un cahier des charges en code fonctionnel, corriger des bugs, organiser une structure logicielle robuste</p>
        </div>

        <h3>‚öôÔ∏è Initialisation des param√®tres du jeu</h3>
        <pre><code>#define SCREEN_WIDTH  320
#define SCREEN_HEIGHT 240
#define ROTATION      1</code></pre>

        <h2>üéÆ Analyse compl√®te du code Arkanoid</h2>

        <h3>üìã Vue d'ensemble du projet</h3>
        <p>Ce code impl√©mente un jeu Arkanoid complet sur microcontr√¥leur PIC avec √©cran TFT, d√©montrant une ma√Ætrise des <strong>syst√®mes embarqu√©s</strong> et de la <strong>programmation en C</strong>.</p>

        <hr>

        <h3>üì¶ Section 1: Inclusions et d√©finitions globales</h3>
        <pre><code>#include "mcc_generated_files/mcc.h"
#include "ILI9341.h"
#include "GFX_Library.h"
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;</code></pre>

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Int√©gration des biblioth√®ques g√©n√©r√©es automatiquement par MCC (MPLAB Code Configurator)</li>
                <li>Utilisation de l'√©cran ILI9341 (320x240 pixels)</li>
                <li>Inclusion des types bool√©ens et fonctions d'affichage</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Automatisme & Informatique industrielle</strong> : Utilisation d'outils de configuration automatique</li>
                <li><strong>√âlectronique & Syst√®mes embarqu√©s</strong> : Interface avec composants externes (√©cran TFT)</li>
            </ul>
        </div>

        <hr>

        <h3>‚öôÔ∏è Section 2: Configuration √©cran et constantes de jeu</h3>
        <pre><code>// === √âcran ===
#define SCREEN_WIDTH  320
#define SCREEN_HEIGHT 240
#define ROTATION      1

// === Raquette ===
#define PADDLE_WIDTH   60
#define PADDLE_HEIGHT  10
#define PADDLE_SPEED   7

// === Balle ===
#define BALL_SIZE      6

// === Briques ===
#define BRICK_ROWS     6
#define BRICK_COLS     10
#define BRICK_WIDTH    30
#define BRICK_HEIGHT   10</code></pre>

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>D√©finition des constantes pour √©viter les "nombres magiques"</li>
                <li>Param√©trage modulaire permettant des ajustements faciles</li>
                <li>Organisation logique par √©l√©ments de jeu</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Math√©matiques & Physique appliqu√©e</strong> : Calculs dimensionnels, positionnement g√©om√©trique</li>
                <li><strong>Communication & PPP</strong> : Code lisible et bien structur√©</li>
            </ul>
        </div>

        <hr>

        <h3>üïπÔ∏è Section 3: Lecture des entr√©es analogiques (Joystick)</h3>
        <pre><code>uint16_t lireJoystickX() {
    ADPCH = 0x02; // RA2
    ADCON0bits.ADON = 1;
    ADCON0bits.ADGO = 1;
    while (ADCON0bits.ADGO);
    return ((uint16_t)ADRESH << 8) | ADRESL;
}

uint16_t lireJoystickY() {
    ADPCH = 0x09; // RB1 = AN9
    ADCON0bits.ADON = 1;
    ADCON0bits.ADGO = 1;
    while (ADCON0bits.ADGO);
    return ((uint16_t)ADRESH << 8) | ADRESL;
}</code></pre>

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Configuration des canaux ADC pour lecture joystick 2 axes</li>
                <li>Gestion des registres de conversion analogique-num√©rique</li>
                <li>Reconstruction de la valeur 10 bits √† partir des registres haut/bas</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Automatisme & Informatique industrielle</strong> : Gestion des entr√©es/sorties, interfa√ßage capteurs</li>
                <li><strong>√âlectronique & Syst√®mes embarqu√©s</strong> : Conversion analogique-num√©rique, registres microcontr√¥leur</li>
            </ul>
        </div>

        <hr>

        <h3>üéµ Section 4: Syst√®me audio et m√©lodies</h3>
        <pre><code>int music[12] = {102,108,115,121,129,136,145,153,162,172,182,193};
// Do(C),Do#(C#),Re(D),Re#(D#),Mi(E),Fa(F),Fa#(F#),Sol(G),Sol#(G#),La(A),La#(A#),Si(B)

void playMenuMusic(void) {
    int menuNotes[] = {0, 4, 7, 0}; // Do, Mi, Sol, Do
    for (int i = 0; i < 4; i++) {
        NCO1INC = ((5 + music[menuNotes[i]] * 1.28) / 4);
        __delay_ms(300);
    }
}</code></pre>

        <img src="images/Sae snake/IMG_0534.jpg" alt="Audio syst√®me">

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Utilisation du module NCO (Numerically Controlled Oscillator) pour g√©n√©rer des fr√©quences</li>
                <li>Tableau de fr√©quences correspondant aux notes musicales</li>
                <li>S√©quences m√©lodiques diff√©rentes selon le contexte (menu, victoire, d√©faite)</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Math√©matiques & Physique appliqu√©e</strong> : Calculs de fr√©quences, g√©n√©ration de signaux</li>
                <li><strong>√âlectronique & Syst√®mes embarqu√©s</strong> : Modules sp√©cialis√©s du microcontr√¥leur (NCO)</li>
            </ul>
        </div>

        <hr>

        <h3>üé® Section 5: Gestion graphique et palettes</h3>
        <pre><code>typedef enum {
    PALETTE_CLASSIQUE,
    PALETTE_JUL,
    PALETTE_PASTEL,
    PALETTE_OCEAN,
    PALETTE_FEU
} PaletteType;

const uint16_t palette_classique[6] = {ILI9341_RED, ILI9341_ORANGE, ILI9341_YELLOW, 
                                       ILI9341_GREEN, ILI9341_BLUE, ILI9341_MAGENTA};

void drawBorders(void) {
    fillRect(0, 20, 5, SCREEN_HEIGHT - 20, ILI9341_BLUE);
    fillRect(SCREEN_WIDTH - 5, 20, 5, SCREEN_HEIGHT - 20, ILI9341_BLUE);
    fillRect(0, 20, SCREEN_WIDTH, 5, ILI9341_BLUE);
}</code></pre>

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Syst√®me de palettes interchangeables pour personnalisation visuelle</li>
                <li>Fonctions de dessin optimis√©es pour l'affichage TFT</li>
                <li>Interface utilisateur attractive avec bordures et √©l√©ments graphiques</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Communication & PPP</strong> : Interface utilisateur intuitive et esth√©tique</li>
                <li><strong>Automatisme & Informatique industrielle</strong> : Gestion d'affichage, IHM (Interface Homme-Machine)</li>
            </ul>
        </div>

        <hr>

        <h3>üß± Section 6: Structure des briques et niveaux</h3>
        <pre><code>typedef struct {
    uint16_t x, y, width, height;
    bool active;
    uint16_t color;
} Brick;

Brick bricks[BRICK_ROWS][BRICK_COLS];

void initBricks(void) {
    switch(level) {
        case 1:  // Vagues d√©cal√©es
            for (uint8_t row = 0; row < BRICK_ROWS; row++) {
                for (uint8_t col = 0; col < BRICK_COLS; col++) {
                    if ((col + row) % 2 == 0) bricks[row][col].active = true;
                }
            }
            break;
        
        case 3:  // C≈ìur
            uint8_t pattern[6][10] = {
                {0,1,0,0,0,0,0,0,1,0},
                {1,1,1,0,0,0,0,1,1,1},
                // ...
            };
            break;
    }
}</code></pre>

        <table>
            <thead>
                <tr>
                    <th>Image 1</th>
                    <th>Image 2</th>
                    <th>Image 3</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><img src="images/Sae snake/IMG_0690.jpg" alt="Niveau 1"></td>
                    <td><img src="images/Sae snake/IMG_0691.jpg" alt="Niveau 2"></td>
                    <td><img src="images/Sae snake/IMG_0696.jpg" alt="Niveau 3"></td>
                </tr>
            </tbody>
        </table>

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Structure de donn√©es optimis√©e pour les briques (position, √©tat, couleur)</li>
                <li>Algorithmes de g√©n√©ration de motifs vari√©s selon le niveau</li>
                <li>Syst√®me de progression avec difficult√© croissante</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Math√©matiques & Physique appliqu√©e</strong> : Algorithmique, motifs g√©om√©triques, modulo</li>
                <li><strong>Automatisme & Informatique industrielle</strong> : Structures de donn√©es, gestion m√©moire</li>
            </ul>
        </div>

        <hr>

        <h3>‚öΩ Section 7: Physique de la balle et collisions</h3>
        <pre><code>void updateBall(void) {
    // Effacement position pr√©c√©dente
    drawBall(ballX, ballY, ILI9341_BLACK);
    
    // Calcul nouvelle position
    int16_t newX = ballX + ballSpeedX;
    int16_t newY = ballY + ballSpeedY;
    
    // Collisions avec bordures
    if (newX <= BALL_SIZE || newX >= SCREEN_WIDTH - BALL_SIZE) 
        ballSpeedX = -ballSpeedX;
    if (newY <= BALL_SIZE) 
        ballSpeedY = -ballSpeedY;
    
    // Collision avec raquette
    if (checkCollision(newX, newY, BALL_SIZE*2, BALL_SIZE*2,
                       paddleX, paddleY, PADDLE_WIDTH, PADDLE_HEIGHT)) {
        ballSpeedY = -level;
        int16_t offset = newX - (paddleX + PADDLE_WIDTH / 2);
        ballSpeedX = offset / 6; // Effet directionnel
    }
}</code></pre>

        <p><strong>Voici le lien vers une vid√©o illustrative :</strong></p>
        <div class="content-box">
            <p><a href="https://youtube.com/shorts/9vQg8wK_2AU?feature=share" target="_blank" style="color: #00bfff;">- Vid√©o 1</a></p>
        </div>

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Impl√©mentation de la physique basique : rebonds, vitesse, direction</li>
                <li>D√©tection de collisions rectangulaires optimis√©e</li>
                <li>Effet directionnel sur la raquette pour contr√¥le avanc√©</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Math√©matiques & Physique appliqu√©e</strong> : Vecteurs, cin√©matique, d√©tection de collisions</li>
                <li><strong>Automatisme & Informatique industrielle</strong> : Algorithmes temps r√©el, optimisation</li>
            </ul>
        </div>

        <hr>

        <h3>üéÆ Section 8: Contr√¥le de la raquette</h3>
        <pre><code>void updatePaddle(void) {
    uint16_t valeurX = lireJoystickX();
    uint16_t valeurY = lireJoystickY();
    
    int16_t newX = paddleX;
    int16_t newY = paddleY;

    // Seuils de d√©tection joystick
    if (valeurX < 400) newX -= PADDLE_SPEED;
    if (valeurX > 624) newX += PADDLE_SPEED;
    
    // Contraintes de mouvement
    if (newX < 0) newX = 0;
    if (newX > SCREEN_WIDTH - PADDLE_WIDTH) 
        newX = SCREEN_WIDTH - PADDLE_WIDTH;
    
    // Mise √† jour graphique
    if (newX != paddleX || newY != paddleY) {
        clearPaddle();
        paddleX = newX;
        paddleY = newY;
        drawPaddle();
    }
}</code></pre>

        <p><strong>Voici le lien vers une vid√©o illustrative :</strong></p>
        <div class="content-box">
            <p><a href="https://youtube.com/shorts/9vQg8wK_2AU?feature=share" target="_blank" style="color: #00bfff;">- Vid√©o 1</a></p>
        </div>

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Conversion des valeurs analogiques en mouvements discrets</li>
                <li>Gestion des limites d'√©cran et contraintes physiques</li>
                <li>Optimisation graphique (redessinage uniquement si changement)</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Automatisme & Informatique industrielle</strong> : Interface homme-machine, temps r√©el</li>
                <li><strong>Math√©matiques & Physique appliqu√©e</strong> : Conversion analogique-num√©rique, seuillage</li>
            </ul>
        </div>

        <hr>

        <h3>üìä Section 9: Interface utilisateur et informations</h3>
        <pre><code>void drawGameInfo(void) {
    char info[32];
    sprintf(info, "Score: %u  Vies: %u", score, lives);
    
    // Effacement zone d'affichage
    fillRect(0, 0, SCREEN_WIDTH, 20, ILI9341_BLACK);
    
    // Affichage texte
    display_setCursor(10, 5);
    display_setTextColor(ILI9341_WHITE, ILI9341_BLACK);
    for (uint8_t i = 0; info[i]; i++) {
        display_print(info[i]);
    }
    
    // Barre de vie graphique
    for (uint8_t i = 0; i < maxVies; i++) {
        uint16_t color = (i < lives) ? ILI9341_RED : ILI9341_DARKGREY;
        fillRect(baseX + i * (segmentW + spacing), baseY, segmentW, segmentH, color);
    }
}</code></pre>

        <img src="images/Sae snake/Vie et score.png" alt="Vie et score">

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Affichage temps r√©el des informations de jeu</li>
                <li>Interface graphique claire avec barres de vie visuelles</li>
                <li>Gestion efficace du rafra√Æchissement d'√©cran</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Communication & PPP</strong> : Design d'interface utilisateur claire</li>
                <li><strong>Automatisme & Informatique industrielle</strong> : IHM, affichage temps r√©el</li>
            </ul>
        </div>

        <hr>

        <h3>üìã Section 10: Menu interactif et s√©lection</h3>
        <pre><code>void showMenu(void) {
    uint8_t paletteIndex = 0;
    bool confirmed = false;
    level = 1;
    
    const char* paletteNames[] = {
        "Classique", "Jul", "Pastel", "Ocean", "Feu"
    };
    
    while (!confirmed) {
        if (refresh) {
            fillScreen(ILI9341_BLACK);
            drawText(60, 20, "Choix du Niveau", ILI9341_WHITE);
            // ... affichage menu
        }
        
        // Gestion boutons
        if (BP_B_GetValue() == 0 && level < 9) level++;
        if (BP_D_GetValue() == 0 && level > 1) level--;
        if (BP_C_GetValue() == 0) {
            paletteIndex = (paletteIndex + 1) % 5;
            currentPalette = (PaletteType)paletteIndex;
        }
        if (BP_A_GetValue() == 0) confirmed = true;
    }
}</code></pre>

        <table>
            <thead>
                <tr>
                    <th>Menu</th>
                    <th>Image</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><img src="images/Sae snake/menu.jpg" alt="Menu"></td>
                    <td><img src="images/Sae snake/IMG_0693.jpg" alt="Image menu"></td>
                </tr>
            </tbody>
        </table>

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Menu de configuration complet avec boutons physiques</li>
                <li>Syst√®me de navigation intuitive</li>
                <li>Personnalisation du gameplay (niveau, palette)</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Communication & PPP</strong> : Interface utilisateur ergonomique</li>
                <li><strong>Automatisme & Informatique industrielle</strong> : Gestion des entr√©es, configuration syst√®me</li>
            </ul>
        </div>

        <hr>

        <h3>üîÑ Section 11: Boucle principale et √©tats de jeu</h3>
        <pre><code>void main(void) {
    // Initialisation syst√®me
    SYSTEM_Initialize();
    SPI1_Open(SPI1_DEFAULT);
    tft_begin();
    
    // S√©quence de d√©marrage
    showIntroScreen();
    showMenu();
    
    // Boucle principale
    while (1) {
        // Gestion pause
        if (BP_E_GetValue() == 0) {
            isPaused = !isPaused;
            // ...
        }
        
        if (!isPaused) {
            updatePaddle();
            updateBall();
            
            // Conditions de victoire/d√©faite
            if (allDestroyed) {
                playVictoryMelody();
                // Reset niveau suivant
            }
            if (lives == 0) {
                playGameOverMelody();
                // Retour menu
            }
        }
        
        __delay_ms(16); // ~60 FPS
    }
}</code></pre>

        <p><strong>Voici le lien vers une vid√©o illustrative :</strong></p>
        <div class="content-box">
            <p><a href="https://youtube.com/shorts/vCBqcKI-Fcc?feature=share" target="_blank" style="color: #00bfff;">- Vid√©o 2</a></p>
        </div>

        <div class="content-box">
            <p><strong>üí° Explication :</strong></p>
            <ul>
                <li>Architecture en machine √† √©tats (intro‚Üímenu‚Üíjeu‚Üífin)</li>
                <li>Boucle de jeu optimis√©e √† ~60 FPS</li>
                <li>Gestion compl√®te du cycle de vie du jeu</li>
            </ul>
            <p><strong>üéØ Lien comp√©tences :</strong></p>
            <ul>
                <li><strong>Automatisme & Informatique industrielle</strong> : Architecture logicielle, temps r√©el</li>
                <li><strong>Communication & PPP</strong> : Exp√©rience utilisateur fluide</li>
            </ul>
        </div>

        <hr>

        <h2>üìö Synth√®se des comp√©tences d√©velopp√©es</h2>

        <h3>üßÆ Math√©matiques & Physique appliqu√©e</h3>
        <div class="content-box">
            <ul>
                <li>‚úÖ Calculs de positions et collisions rectangulaires</li>
                <li>‚úÖ G√©n√©ration de fr√©quences audio (NCO)</li>
                <li>‚úÖ Algorithmes de motifs g√©om√©triques</li>
                <li>‚úÖ Gestion des vecteurs vitesse/direction</li>
            </ul>
        </div>

        <h3>‚öôÔ∏è Automatisme & Informatique industrielle</h3>
        <div class="content-box">
            <ul>
                <li>‚úÖ Programmation microcontr√¥leur PIC en C</li>
                <li>‚úÖ Gestion temps r√©el (boucle 60 FPS)</li>
                <li>‚úÖ Interface avec p√©riph√©riques (ADC, SPI, GPIO)</li>
                <li>‚úÖ Architecture logicielle modulaire</li>
            </ul>
        </div>

        <h3>üîå √âlectronique & Syst√®mes embarqu√©s</h3>
        <div class="content-box">
            <ul>
                <li>‚úÖ Interface √©cran TFT via SPI</li>
                <li>‚úÖ Lecture capteurs analogiques (joystick)</li>
                <li>‚úÖ G√©n√©ration audio par NCO</li>
                <li>‚úÖ Gestion des entr√©es num√©riques (boutons pull-up)</li>
            </ul>
        </div>

        <h3>üí¨ Communication & PPP</h3>
        <div class="content-box">
            <ul>
                <li>‚úÖ Code document√© et structur√©</li>
                <li>‚úÖ Interface utilisateur intuitive</li>
                <li>‚úÖ Menu de configuration ergonomique</li>
                <li>‚úÖ Exp√©rience de jeu engageante</li>
            </ul>
        </div>

        <hr>

        <h2>üåü Points forts du projet</h2>
        <div class="content-box">
            <ol>
                <li><strong>Int√©gration compl√®te</strong> : Audio, vid√©o, contr√¥les, tout fonctionne ensemble</li>
                <li><strong>Code modulaire</strong> : Fonctions bien s√©par√©es, r√©utilisables</li>
                <li><strong>Interface riche</strong> : Menus, palettes, niveaux progressifs</li>
                <li><strong>Optimisation</strong> : Gestion efficace de l'affichage et des ressources</li>
                <li><strong>Gameplay vari√©</strong> : Diff√©rents patterns de briques, difficult√© croissante</li>
            </ol>
        </div>

        <hr>

        <h2>üéØ Apprentissage critique d√©montr√©</h2>
        <div class="content-box">
            <p><strong>‚úÖ Transformation cahier des charges ‚Üí code fonctionnel</strong></p>
            <ul>
                <li>Analyse des besoins du jeu Arkanoid</li>
                <li>Impl√©mentation de toutes les fonctionnalit√©s demand√©es</li>
            </ul>

            <p><strong>‚úÖ D√©bogage et correction</strong></p>
            <ul>
                <li>Gestion des collisions complexes</li>
                <li>Optimisation de l'affichage pour √©viter les scintillements</li>
                <li>Calibrage des seuils du joystick analogique</li>
            </ul>

            <p><strong>‚úÖ Int√©gration mat√©riel/logiciel</strong></p>
            <ul>
                <li>Ma√Ætrise de l'√©cosyst√®me MPLAB X / MCC</li>
                <li>Interface avec multiples p√©riph√©riques simultan√©ment</li>
            </ul>
        </div>

        <hr>

        <h2>‚ö†Ô∏è Probl√®mes rencontr√©s et solutions</h2>
        <div class="content-box">
            <ul>
                <li>Ajustement des dimensions du bo√Ætier apr√®s la premi√®re impression 3D.</li>
                <li>Mauvais c√¢blage initial du PCB : correction apr√®s analyse du sch√©ma.</li>
                <li>Probl√®me de brasage du PCB (surchauffe, d√©t√©rioration) : recommencer le brasage.</li>
            </ul>
        </div>

        <hr>

        <h2>üéì Comp√©tences d√©velopp√©es</h2>
        <table>
            <thead>
                <tr>
                    <th>Mati√®re</th>
                    <th>Comp√©tence d√©velopp√©e</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Automatisme & Informatique industrielle</td>
                    <td>Organisation de projet, programmation microcontr√¥leur</td>
                </tr>
                <tr>
                    <td>√âlectronique & Syst√®mes embarqu√©s</td>
                    <td>Sch√©ma, routage, conception PCB</td>
                </tr>
                <tr>
                    <td>Math√©matiques & Physique appliqu√©e</td>
                    <td>Calculs dimensionnels, ajustements de mesures</td>
                </tr>
                <tr>
                    <td>Communication & PPP</td>
                    <td>Argumentation, justification technique</td>
                </tr>
            </tbody>
        </table>

    </div>

    <script>
        // ===== NAVIGATION SCROLL =====
        window.addEventListener('scroll', () => {
            const navbar = document.querySelector('nav');
            if (window.scrollY > 50) {
                navbar.style.background = 'rgba(15, 32, 39, 0.98)';
            } else {
                navbar.style.background = 'linear-gradient(135deg, rgba(15, 32, 39, 0.95), rgba(44, 83, 100, 0.95))';
            }
        });

        // ===== HAMBURGER MENU =====
        const hamburger = document.querySelector('.hamburger');
        const navMenu = document.querySelector('.nav-menu');

        if (hamburger) {
            hamburger.addEventListener('click', () => {
                hamburger.classList.toggle('active');
                navMenu.classList.toggle('active');
            });
        }
    </script>
</body>
</html>